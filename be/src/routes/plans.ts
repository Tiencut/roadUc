import express from 'express'
import fs from 'fs'
import path from 'path'
import * as db from '../db.js'

const router = express.Router()
const EXPORTS_DIR = path.join(process.cwd(), 'data', 'exports')
if (!fs.existsSync(EXPORTS_DIR)) fs.mkdirSync(EXPORTS_DIR, { recursive: true })

function generatePlanFromAnswers(answers: any) {
  // naive rule-based generator for MVP
  const steps: any[] = []
  let stepId = 1
  if (answers && answers.goal) {
    steps.push({ id: stepId++, title: `Define goal: ${answers.goal}`, content: `Target visa: ${answers.goal}` })
  }
  if (answers && answers.education) {
    steps.push({ id: stepId++, title: `Prepare education documents`, content: `Gather diplomas, transcripts for ${answers.education}` })
  }
  if (answers && answers.documents && Array.isArray(answers.documents)) {
    steps.push({ id: stepId++, title: `Collect required documents`, content: answers.documents.join(', ') })
  }
  // default steps
  steps.push({ id: stepId++, title: 'Submit application', content: 'Complete forms and submit to authority' })
  steps.push({ id: stepId++, title: 'Wait for decision', content: 'Monitor status and respond to requests' })
  return steps
}

// POST /api/plans - create a plan from survey
router.post('/plans', async (req, res) => {
  try {
    const body = req.body || {}
    const key = body.key || `plan:${Date.now().toString(36)}`
    const answers = body.answers || {}
    const userId = body.userId || null

    const generated = generatePlanFromAnswers(answers)

    const created = await db.createMigrationPlan(key, { userId, answers, generatedSteps: generated, status: 'generated' })
    return res.json({ ok: true, plan: created })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

// GET /api/plans/:key
router.get('/plans/:key', async (req, res) => {
  try {
    const key = String(req.params.key)
    const p = await db.getMigrationPlanByKey(key)
    if (!p) return res.status(404).json({ error: 'Not found' })
    return res.json({ ok: true, plan: p })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

import { authenticateJWT, requirePremium } from '../middleware.js'

// POST /api/plans/:key/export - generate an HTML export (stub for PDF). Require authenticated premium user.
router.post('/plans/:key/export', authenticateJWT, requirePremium, async (req, res) => {
  try {
    const key = String(req.params.key)
    const p = await db.getMigrationPlanByKey(key)
    if (!p) return res.status(404).json({ error: 'Plan not found' })

    const filename = `plan-${key.replace(/[:]/g,'-')}-${Date.now().toString(36)}.html`
    const filePath = path.join(EXPORTS_DIR, filename)

    // styled HTML rendering for better PDF output
    function renderPlanHTML(plan: any) {
      const answers = plan.answers || {}
      const steps = Array.isArray(plan.generatedSteps) ? plan.generatedSteps : (plan.generatedSteps || [])
      const created = new Date(plan.createdAt || Date.now()).toLocaleString()
      const css = `
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color: #111827; }
        .container { max-width: 800px; margin: 32px auto; padding: 24px; border: 1px solid #e5e7eb; border-radius: 8px; }
        h1 { font-size: 20px; margin-bottom: 8px; }
        .meta { font-size: 12px; color: #6b7280; margin-bottom: 16px }
        .answers { background: #f9fafb; padding: 12px; border-radius: 6px; margin-bottom: 16px }
        .steps ol { padding-left: 18px; }
        .step { padding: 12px; border: 1px solid #e6eef8; border-radius: 6px; margin-bottom: 10px; background: #ffffff }
        .step .title { font-weight: 600; margin-bottom: 6px }
        footer { margin-top: 22px; font-size: 12px; color: #9ca3af }
      `

      let answersHtml = ''
      for (const k of Object.keys(answers || {})) {
        const v = answers[k]
        answersHtml += `<div><strong>${String(k)}</strong>: ${Array.isArray(v) ? String(v.join(', ')) : String(v)}</div>`
      }

      let stepsHtml = ''
      for (const s of steps) {
        stepsHtml += `<div class="step"><div class="title">${s.title}</div><div class="content">${s.content || ''}</div></div>`
      }

      return `<!doctype html><html><head><meta charset="utf-8"><title>Plan ${plan.key}</title><style>${css}</style></head><body><div class="container"><h1>Kế hoạch: ${plan.key}</h1><div class="meta">Tạo lúc: ${created}</div><div class="answers"><h3>Thông tin đầu vào</h3>${answersHtml}</div><div class="steps"><h3>Các bước đề xuất</h3>${stepsHtml}</div><footer>Generated by Road To Úc • ${new Date().getFullYear()}</footer></div></body></html>`
    }

    const html = renderPlanHTML(p)
    fs.writeFileSync(filePath, html, 'utf-8')

    const rec = await db.createExportRecord({ planId: (p as any).id, filename, filePath })

    // Optionally generate PDF if environment enables it and puppeteer is available
    if (process.env.USE_PDF === '1' || process.env.USE_PDF === 'true') {
      try {
        const puppeteer = await import('puppeteer')
        const browser = await puppeteer.launch({ args: ['--no-sandbox', '--disable-setuid-sandbox'] })
        const page = await browser.newPage()
        await page.setContent(html, { waitUntil: 'networkidle0' })
        const pdfName = filename.replace(/\.html$/, '.pdf')
        const pdfPath = path.join(EXPORTS_DIR, pdfName)
        await page.pdf({ path: pdfPath, format: 'A4', printBackground: true })
        await browser.close()
        await db.createExportRecord({ planId: (p as any).id, filename: pdfName, filePath: pdfPath })
        return res.json({ ok: true, export: rec, url: `/data/exports/${filename}`, pdf: `/data/exports/${pdfName}` })
      } catch (e) {
        // ignore PDF generation errors and return HTML URL
        console.warn('PDF generation unavailable or failed', e)
        return res.json({ ok: true, export: rec, url: `/data/exports/${filename}` })
      }
    }

    return res.json({ ok: true, export: rec, url: `/data/exports/${filename}` })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

export default router