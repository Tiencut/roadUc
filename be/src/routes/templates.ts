import express from 'express'
import * as db from '../db.js'

const router = express.Router()

// POST /api/templates - create template (admin)
router.post('/templates', async (req, res) => {
  try {
    const body = req.body || {}
    if (!body.name || !body.fields) return res.status(400).json({ error: 'Missing name or fields' })
    const created = await db.createTemplate({ name: body.name, description: body.description, fields: body.fields })
    return res.json({ ok: true, template: created })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

// GET /api/templates
router.get('/templates', async (req, res) => {
  try {
    const list = await db.listTemplates()
    return res.json({ ok: true, templates: list })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

// GET /api/templates/:id
router.get('/templates/:id', async (req, res) => {
  try {
    const id = Number(req.params.id)
    const t = await db.getTemplateById(id)
    if (!t) return res.status(404).json({ error: 'Not found' })
    return res.json({ ok: true, template: t })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

import { authenticateJWT, requirePremium, ensureAdmin } from '../middleware.js'

// POST /api/templates/upload - admin uploads HTML and creates a template
router.post('/templates/upload', authenticateJWT, async (req: any, res: any) => {
  try {
    if (!ensureAdmin(req, res)) return
    const body = req.body || {}
    if (!body.name || !body.html) return res.status(400).json({ error: 'Missing name or html content' })
    const path = require('path')
    const fs = require('fs')
    const dir = path.join(process.cwd(), 'data', 'templates')
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })
    const filename = `template-${Date.now().toString(36)}.html`
    const filePath = path.join(dir, filename)
    fs.writeFileSync(filePath, body.html, 'utf-8')

    // fields can be provided or auto-detected via placeholder syntax {{field}}
    const providedFields = body.fields || {}
    const placeholders: any = {}
    const re = /{{\s*([a-zA-Z0-9_]+)\s*}}/g
    let m
    while ((m = re.exec(body.html)) !== null) {
      placeholders[m[1]] = providedFields[m[1]] || m[1]
    }

    const created = await db.createTemplate({ name: body.name, description: body.description, fields: Object.keys(placeholders).length ? placeholders : (body.fields || {}), filePath })
    return res.json({ ok: true, template: created })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

// POST /api/templates/:id/generate - apply answers to template and return an HTML export (stub). Require authenticated premium user.
router.post('/templates/:id/generate', authenticateJWT, requirePremium, async (req, res) => {
  try {
    const id = Number(req.params.id)
    const t = await db.getTemplateById(id)
    if (!t) return res.status(404).json({ error: 'Template not found' })
    const answers = req.body?.answers || {}
    // simple placeholder replacement: fields in template.fields map fieldName->label
    const filename = `template-${id}-${Date.now().toString(36)}.html`
    const path = require('path')
    const fs = require('fs')
    const dir = path.join(process.cwd(), 'data', 'exports')
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })
    const filePath = path.join(dir, filename)
    const fields = t.fields || {}
    const created = new Date().toLocaleString()
    const css = `
      body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color: #111827 }
      .container { max-width: 800px; margin: 28px auto; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px }
      h1 { font-size: 18px }
      table { width: 100%; border-collapse: collapse }
      td { padding: 8px; border-bottom: 1px solid #f1f5f9 }
      .label { width: 30%; color: #374151; font-weight: 600 }
    `

    let rows = ''
    for (const k of Object.keys(fields)) {
      const label = fields[k]
      const val = answers[k] ?? ''
      rows += `<tr><td class="label">${label}</td><td>${String(val)}</td></tr>`
    }

    const html = `<!doctype html><html><head><meta charset="utf-8"><title>${t.name}</title><style>${css}</style></head><body><div class="container"><h1>${t.name}</h1><div class="meta">Tạo: ${created}</div><table>${rows}</table><footer style="margin-top:18px;font-size:12px;color:#9ca3af">Generated by Road To Úc</footer></div></body></html>`
    fs.writeFileSync(filePath, html, 'utf-8')
    const rec = await db.createExportRecord({ templateId: id, filename, filePath })

    if (process.env.USE_PDF === '1' || process.env.USE_PDF === 'true') {
      try {
        const puppeteer = await import('puppeteer')
        const browser = await puppeteer.launch({ args: ['--no-sandbox', '--disable-setuid-sandbox'] })
        const page = await browser.newPage()
        await page.setContent(html, { waitUntil: 'networkidle0' })
        const pdfName = filename.replace(/\.html$/, '.pdf')
        const pdfPath = path.join(dir, pdfName)
        await page.pdf({ path: pdfPath, format: 'A4', printBackground: true })
        await browser.close()
        await db.createExportRecord({ templateId: id, filename: pdfName, filePath: pdfPath })
        return res.json({ ok: true, export: rec, url: `/data/exports/${filename}`, pdf: `/data/exports/${pdfName}` })
      } catch (e) {
        console.warn('PDF generation unavailable or failed', e)
        return res.json({ ok: true, export: rec, url: `/data/exports/${filename}` })
      }
    }

    return res.json({ ok: true, export: rec, url: `/data/exports/${filename}` })
  } catch (e: any) { res.status(500).json({ error: e?.message || String(e) }) }
})

export default router